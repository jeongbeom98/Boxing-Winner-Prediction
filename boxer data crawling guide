1. 사이트 자체가 로그인을 해야 정보를 확인할 수 있었으므로 셀레니움을 사용해서 로그인을 해야함
2. 셀레니움으로 월드랭킹으로 들어가서 1페이지 1등부터 150페이지 1750등까지 크롤링하기로 함
    (이외의 선수들은 정보도 많이 없을뿐더러 굳이 비교를 할 필요가 없다는 판단)
3. 한 페이지에 총 50명의 선수가 있으므로 한명의 선수를 크롤링하고 난 후 뒤로 가서 그 다음 선수로 들어가서 크롤링하게끔 코드 구현
4. 선수 정보 크롤링 코드 구현 정리
	(1) 각 선수들 정보는 왼쪽테이블, 오른쪽테이블로 나뉘어져 있음 html을 확인한 결과, 각각 다른 주소를 가지고 있는것을 확인
	(2) 각 선수들마다 제공되는 정보의 양도 다르며 정보의 수에 따라 html의 인덱싱 값 또한 다른것을 확인
	(3) 따라서 왼쪽 오른쪽 테이블을 구분지어야 하며 동시에 각 선수들마다 html의 인덱싱 번호가 가리키는 정보가 다르기 때문에 규칙성을 띄지 않았음
	(4) 좀 더 정확한 크롤링을 위해서 좀 더 세분화한 크롤링의 필요성을 느껴 선수들 정보의 Label과 Value의 값을 각각 다르게 크롤링하기로 결정
	(5) List형식으로 크롤링 하게 된다면 Label과 Value의 값이 매칭되지 않기 때문에 Dictionary 형태로 각각의 값들을 매칭시켜서 크롤링하게 만듦
	(6) Dict형식으로 크롤링을 하다보니 선수들마다 인덱스 번호가 가리키는 정보가 달라도 Label값을 Key값으로 매칭시키니 동일한 Key값들을 기준으로 크롤링 할 수 있었음
	(7) 그러나 선수들마다 제공되는 정보의 양이 다르기때문에 html의 인덱스 번호를 일정하게 주지를 못함
	(8) 결국 try ~ except 구문을 활용하여 out of index의 오류를 대처
	(9) 전체적인 코드는 오른쪽 왼쪽 테이블을 나누는 for문 하나, 선수들의 정보들의 html의 XPath의 값들을 가져오는 for문 하나로 이중for문을 돌려 크롤링
	(10) 선수정보는 약간의 데이터 전처리가 필요해서 Dict형식으로 받은 데이터들을 Key값을 기준으로 전처리까지 실행
		e.g) reach, height 값들은 cm 값만, titles는 개수로 변환 등

5. 선수 정보를 크롤링하는 도중에 각 선수들 페이지에 경기전적들이 있어 해당 경기정보까지 크롤링하기로 결정 
	=> 추후에 경기정보를 기준으로  Player_1, Player_2로 구성해서 선수 이름을 기준으로 데이터 프레임 병합예정 -> 머신러닝 모델링 구현시 win, lose, draw의 정보 활용가능성
6. 경기전적 크롤링 코드 구현 정리
	(1) 경기전적은 날짜별로 구성되어 있고 날짜별로 id값이 다른것을 확인
	(2) attrs와 정규식을 활용해서 정수값이 7자리 혹은 6자리인 id값만 뽑아옴
	(3) 경기전적 중 본인 이름, 상대 선수 이름, 매치결과, 매치 라운드 수를 크롤링함
	(4) 뽑아온 데이터들을 Dict 형식으로 저장
	
7. 데이터 저장을 Dict 형식으로 했기 때문에 csv라이브러리에서 DictWriter를 사용 (fieldname을 지정해주면 동일한 Key값을 매칭시켜 Value값을 저장)
   선수정보와 경기정보를 각각 따로 csv파일로 저장 (file 옵션 'a'사용해서 Dict형식의 데이터가 하나 생길때마다 csv파일에 추가해줌)
8. 코드를 작성한 후 약간의 자동화를 위해서 while문을 활용 (페이지 넘버), 내가 시작할 페이지와 시작할 선수들의 index번호, 어디까지 크롤링할 페이지를 input값으로 받게끔 만들어 놓아서 유동성을 높임 (각각 크롤링할 페이지 수를 정함)
9. 제일 문제였던 점은 Login, Click 하는 와중에 Capcha가 걸리는 문제, 가끔씩 intercept오류 때문에 크롤링이 끊기게 됨.
	=> Click intercept 오류는 try ~ except문으로 전체 코드 중 오류가 발생하면 끊긴 페이지와 선수의 index번호를 다시 재할당시키고 driver를 재실행 시켜 끊긴 부분부터 다시 크롤링하게 구현
	=> Capcha문제는 계정을 바꾸면 약간은 해결이 되는 것을 확인한 후, trial_num이라는 변수를 만들어 Capcha가 발생하면 몇번정도는 driver를 재실행 후 그래도 안되면 다른 계정으로 로그인 하게끔 ID, PW를 재할당 후 send_key로 보냄
	=> 그래도 Capcha 문제가 해결되지 않으면 break를 걸어놓음
	=> 결론적으로 Capcha가 걸리더라도 약간은 풀어낼 수 있었고 자잘한 Click intercept가 발생해도 자동으로 재실행을 해서 코드의 자동화를 높일 수 있었음.
10. 전체적인 코드의 while문은 input한 마지막 페이지의 url 넘버를 초과하면 저절로 break하게 만들어 놓음
11. 처음에 중구난방이였던 코드들을 한 코드로 합쳐서 실행, 결과적으로 크롤링 속도도 올라갔으며 오류 또한 어느정도 자연스럽게 해결할 수 있었음.
